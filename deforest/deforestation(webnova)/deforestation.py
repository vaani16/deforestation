# -*- coding: utf-8 -*-
"""deforestation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gGzA5SHoUoqllLW-gdsmvJqnGW2B2STQ
    "pip install imageio scikit-image
"""



import cv2
import numpy as np
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
from collections import Counter
import imageio.v2 as imageio
from skimage.transform import resize
import matplotlib.pyplot as plt
import os


def find_vector_set(diff_image, new_size):
    i = 0
    j = 0
    vector_set = np.zeros((int(new_size[0] * new_size[1] / 25), 75))  # Change 25 to 75
    while i < vector_set.shape[0]:
        while j < new_size[0]:
            k = 0
            while k < new_size[1]:
                block   = diff_image[j:j+5, k:k+5]
                feature = block.ravel()
                vector_set[i, :] = feature
                k = k + 5
            j = j + 5
        i = i + 1
    mean_vec   = np.mean(vector_set, axis = 0)
    vector_set = vector_set - mean_vec
    print("loop 1 done ")
    return vector_set, mean_vec
    
    

def find_FVS(EVS, diff_image, mean_vec, new):
    i = 2
    feature_vector_set = []
    while i < new[0] - 2:
        j = 2
        while j < new[1] - 2:
            block = diff_image[i-2:i+3, j-2:j+3]
            feature = block.flatten()
            feature_vector_set.append(feature)
            j = j+1
        i = i+1
    FVS = np.dot(feature_vector_set, EVS)
    FVS = FVS - mean_vec
    print("\nfeature vector space size", FVS.shape)
    print("loop 2 done ")
    return FVS
   
    
def clustering(FVS, components, new):
    print("line0")
    kmeans = KMeans(components, verbose = 0,n_init=10)
    print("line1")
    kmeans.fit(FVS)
    output = kmeans.predict(FVS)
    count  = Counter(output)
    print("line2")
    least_index = min(count, key = count.get)
    change_map  = np.reshape(output,(new[0] - 4, new[1] - 4))
    print("loop 3 done ")
    return least_index, change_map,output
    
    
def find_PCAKmeans(imagepath1, imagepath2):
    image1 = imageio.imread(imagepath1)
    image2 = imageio.imread(imagepath2)
    new_size = np.floor_divide(np.asarray(image1.shape), 5) * 5
    image1 = cv2.resize(image1, (new_size[1], new_size[0])).astype(np.int16)
    image2 = cv2.resize(image2, (new_size[1], new_size[0])).astype(np.int16)
    diff_image = abs(image1 - image2)
    imageio.imsave('diff.jpg', diff_image.astype(np.uint8))
    vector_set, mean_vec = find_vector_set(diff_image, new_size)
    pca     = PCA()
    pca.fit(vector_set)
    EVS = pca.components_
    FVS     = find_FVS(EVS, diff_image, mean_vec, new_size)
    components = 3
    least_index, change_map,output = clustering(FVS, components, new_size)
    
    labels_reshaped = np.reshape(output, (new_size[0] - 4, new_size[1] - 4))
    avg_pixel_values = {}
    for label in np.unique(output):
        # Find the pixels in the difference image that correspond to the current label
        
        label_pixels = diff_image[2:-2, 2:-2][labels_reshaped == label]
        
        # Calculate the average pixel value for the current label
        avg_pixel_values[label] = np.mean(label_pixels)

    # Print the average pixel values for each label
    for label, avg_value in avg_pixel_values.items():
        print(f"Label {label}: Average pixel value = {avg_value}")
    kernel = np.ones((5,5),np.uint8)
    cleanChangeMap = cv2.erode(change_map.astype(np.uint8),kernel)  # Convert to uint8 before erosion
    imageio.imsave(os.path.join('../output_queue', 'changemap.jpg'), change_map.astype(np.uint8))
    imageio.imsave(os.path.join('../output_queue', 'cleanchangemap.jpg'), cleanChangeMap)
    
    

if __name__ == "__main__":
    a = '../input_queue/deforest1.jpeg'
    b = '../input_queue/deforest2.jpeg'
    find_PCAKmeans(a,b)
print("done")
    
    
